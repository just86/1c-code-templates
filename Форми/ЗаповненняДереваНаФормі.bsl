// Робота з деревом на керованій формі
// Приклад заповнення дерева з результату запиту з ієрархією

// ==================== КЛІЄНТСЬКА ЧАСТИНА ====================

&НаКлиенте
Процедура ЗаповнитиДерево(Команда)
    ЗаповнитиДеревоНаСервере();
КонецПроцедуры


// ==================== СЕРВЕРНА ЧАСТИНА ====================

&НаСервере
Процедура ЗаповнитиДеревоНаСервере()
    
    // Запит з ієрархічною вибіркою
    Запрос = Новый Запрос;
    Запрос.Текст = 
        "ВЫБРАТЬ
        |	АСТРА_Аналоги.Родитель КАК Родитель
        |ПОМЕСТИТЬ ВТ
        |ИЗ
        |	Справочник.АСТРА_Аналоги КАК АСТРА_Аналоги
        |ГДЕ
        |	АСТРА_Аналоги.Номенклатура = &Номенклатура
        |;
        |
        |////////////////////////////////////////////////////////////////////////////////
        |ВЫБРАТЬ
        |	АСТРА_Аналоги.Ссылка КАК Аналог,
        |	АСТРА_Аналоги.AxialКод КАК AxialКод,
        |	АСТРА_Аналоги.Номенклатура КАК Номенклатура,
        |	АСТРА_Аналоги.Родитель КАК РодительАналога,
        |	АСТРА_Аналоги.Код КАК Код
        |ИЗ
        |	Справочник.АСТРА_Аналоги КАК АСТРА_Аналоги
        |ГДЕ
        |	АСТРА_Аналоги.Ссылка В ИЕРАРХИИ
        |			(ВЫБРАТЬ
        |				ВТ.Родитель КАК Родитель
        |			ИЗ
        |				ВТ КАК ВТ)
        |
        |УПОРЯДОЧИТЬ ПО
        |	АСТРА_Аналоги.Ссылка Иерархия";
    
    Запрос.УстановитьПараметр("Номенклатура", Номенклатура);
    
    // Перетворення реквізиту форми у дерево значень
    ДеревоНаСервере = РеквизитФормыВЗначение("ДеревоАналогов");
    ДеревоНаСервере.Строки.Очистить();
    
    // Отримання вибірки з групуванням
    ВыборкаПоГруппировкам = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
    
    // Рекурсивне заповнення дерева
    ЗаполнитьДеревоРекурсивно(ДеревоНаСервере.Строки, ВыборкаПоГруппировкам);
    
    // Повернення значення в реквізит форми
    ЗначениеВРеквизитФормы(ДеревоНаСервере, "ДеревоАналогов");
    
КонецПроцедуры


&НаСервере
Процедура ЗаполнитьДеревоРекурсивно(СтрокиДерева, Выборка)
    
    Пока Выборка.Следующий() Цикл
        
        // Додаємо нову строку в дерево
        НоваяСтрока = СтрокиДерева.Добавить();
        ЗаполнитьЗначенияСвойств(НоваяСтрока, Выборка);
        
        // Отримуємо підлеглу вибірку
        ВыборкаПодчиненная = Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
        
        // Якщо є підлеглі елементи
        Если ВыборкаПодчиненная.Количество() <> 0 Тогда
            
            Если НЕ ЗначениеЗаполнено(НоваяСтрока.Родитель) Тогда
                // Для елементів верхнього рівня
                ЗаполнитьДеревоРекурсивно(НоваяСтрока.Строки, Выборка);
            Иначе
                // Для вкладених елементів
                ЗаполнитьДеревоРекурсивно(НоваяСтрока.Строки, ВыборкаПодчиненная);
            КонецЕсли;
            
        КонецЕсли;
        
    КонецЦикла;
    
КонецПроцедуры


// ==================== ОПТИМІЗАЦІЇ ====================
//
// 1. Використовується обхід "ПоГруппировкам" для ефективної роботи з ієрархією
// 2. Рекурсивне заповнення дерева зменшує кількість звернень до даних
// 3. Перетворення реквізиту форми в об'єкт дозволяє масово очищувати дерево
// 4. ЗаполнитьЗначенияСвойств() замість поелементного присвоєння
//
// ==================== ТИПОВІ ПОМИЛКИ ====================
//
// ❌ Неправильно: багаторазові запити для кожного рівня
// ✅ Правильно: один запит з УПОРЯДОЧИТЬ ПО Иерархия + рекурсивна обробка
//
// ❌ Неправильно: Элементы.ДеревоАналогов.Строки.Очистить()
// ✅ Правильно: використання РеквизитФормыВЗначение() для роботи з деревом
